      SUBROUTINE GETBRDGE
C	EXTRAN BLOCK
      include 'tapes.inc'
      include 'contr.inc'
      include 'pipe.inc'
      include 'bridges.inc'
      NBR = 0
      DO N=1,NC
      NBRGE(N) = 0
      IF(NKLASS(N).NE.12) CYCLE
      NBR = NBR + 1
  10  continue
      read(n5,*,end=999) CC
      if (CC.EQ.'C5') THEN
      BACKSPACE(N5)
      NBRGE(N) = NBR
      CALL BRIDGE(NBR,N)
      else
      goto 10
      endif
      ENDDO
      return
  999 write(n6,*) ' ERROR - All Bridge Data Not Found'
      write(n6,*) '         Was trying to find data for conduit ',
     ancond(N),' bridge data - ',stheta(n)
      stop 'Bridge data not found'
      end

      SUBROUTINE HBRIDGE(N,DEPTH,HRAD,AREA,WIDTH)
CIM RETURNS HRAD,AREA,WIDTH, GIVEN DEPTH
CIM
      INCLUDE 'TAPES.INC'
      INCLUDE 'BRIDGES.INC'
      INCLUDE 'PIPE.INC'
      M = NBRGE(N)
      FDEPTH = DEPTH/DEEP(N)
      IF (FDEPTH.GE.1.0) FDEPTH = 1.0
      IDEPTH = 1 + IFIX(FDEPTH*(maxbpnt-1))
      IF(IDEPTH.GT.MAXBPNT-1) IDEPTH = MAXBPNT-1
      DELTA= (FDEPTH - (IDEPTH-1.0)/(MAXBPNT-1.0))*(maxbpnt-1)
cim      WRITE(*,*) N,M,DEPTH,FDEPTH,IDEPTH,DELTA
cim      WRITE(*,*) BRTW(M,IDEPTH)
cim      WRITE(*,*) BRTW(M,IDEPTH+1)
      WIDTH=BRTW(M,IDEPTH)+(BRTW(M,IDEPTH+1)-BRTW(M,IDEPTH))*DELTA
      AREA=BRAREA(M,IDEPTH)+(BRAREA(M,IDEPTH+1)-BRAREA(M,IDEPTH))*DELTA
      HRAD=BRHYD(M,IDEPTH)+(BRHYD(M,IDEPTH+1)-BRHYD(M,IDEPTH))*DELTA
      RETURN
      END

      SUBROUTINE BRIDGE(IBR,icond)
cim  bridge routine created by Brett Cunningham 7/97
cim  modified and incorporated into SWMM44 by C. Moore 3/97
cim  computes Area, Hydraulic radius, topwidth versus depth data
cim  for bridge input
cim
C  C5  BRDGNO  NUMHN  NUMST  NMPIER
C  C6  VMAN(1)  STMAT(1)  VMAN(2)  STMAN(2) ....
C  C7  ELSTA(1,1)  ELSTA(2,1)  ELSTA(1,2)  ELSTA(2,2)  ELSTA(1,3)  ELSTA(2,3) ....
C  C8  PIERW(1)  PCLSTA(1)  CHORDL(1)  PIERW(1)  PCLSTA(2)  CHORDL(2) ....
C    CAN GET "SMOOTH PIER" POINTS FROM NH LINES
C
C
C  C5 - BRIDGE ROUGHNESS, LOSS, CROSS-SECTION, AND PIER LINE
C  BRDGNO     = BRIDGE IDENTIFIER NUMBER
C  NUMHN      = NUMBER FOR Mannings n,STATION PAIRS
C  NUMST      = NUMBER OF ELEVATION,STATION PAIRS ON GR LINE(S)
C  NMPIER     = NUMBER OF PIERS (UP TO MAXPR)
C
C  C6 - HORIZONTAL MANNING'S n AND "SMOOTH PIER" LINE
C  VMAN(1)     = MANNING'S n FROM LEFT OF BRIDGE SECTION TO STMAN(1)
C  STMAN(1)     = STATION OF FIRST CHANGE IN n OR LOCATION OF FIRST
C               "SMOOTH PIER" (FT)
C  VMAN(2)     = MANNING'S n FROM STMAN(1) TO STMAN(2)
C  STMAN(2)     = STATION OF SECOND CHANGE IN n OR LOCATION OF SECOND
C               "SMOOTH PIER" (FT)
C
C  C7 - CROSS-SECTION LINE
C  ELSTA(1,1) = ELEVATION OF FIRST CROSS-SECTION POINT (FT)
C  ELSTA(2,1) = STATION OF FIRST CROSS-SECTION POINT (FT)
C  ELSTA(1,2) = ELEVATION OF SECOND CROSS-SECTION POINT (FT)
C  ELSTA(2,2) = STATION OF SECOND CROSS-SECTION POINT (FT)
C
C  C8 - BRIDGE PIER AND LOW CHORD LINE
C  PIERW(1)   = PIER WIDTH OF FIRST PIER (FT)
C  PCLSTA(1)  = CENTERLINE STATION OF FIRST PIER (FT)
C  CHORDL(1)  = LOW CHORD AT FIRST PIER (FT)
C  PIERW(2)   = PIER WIDTH OF SECOND PIER (FT)
C  PCLSTA(2)  = CENTERLINE STATION OF SECOND PIER (FT)
C  CHORDL(2)  = LOW CHORD AT SECOND PIER (FT)
C
C  NUMCEL     = NUMBER OF BRIDGE CELLS
C  IPRGHT     = 0 IF RIGHT OF RIGHT-MOST CELL IS DEFINED BY PR POINT
C             = 1 IF RIGHT OF RIGHT-MOST CELL IS DEFINED BY GR POINT(S)
C
C  BRDEP         = DEPTH OF BRIDGE CURVE AT THE Nth POINT FOR BRIDGE IBR
C  BRHYD(IBR,N)  = HYDRAULIC RADIUS OF BRIDGE CURVE AT THE Nth POINT FOR BRIDGE IBR
C  BRAREA(IBR,N) = AREA OF BRIDGE CURVE AT THE Nth POINT FOR BRIDGE IBR
C  BRTW(IBR,N)   = TOP WIDTH OF BRIDGE CURVE AT THE Nth POINT FOR BRIDGE IBR
C  ROUGHN(I)     = ROUGHNESS OF CELL I
c     maxhn = maximum number of mannings roughness/station pairs
c     maxst = maximum number of elevation/station pairs
      include 'tapes.inc'
      include 'bridges.inc'
      include 'contr.inc'
      include 'pipe.inc'
      DIMENSION  VMAN(maxhn),STMAN(maxhn),ELSTA(2,maxst),PIERW(maxpr)
     +,PCLSTA(maxpr),CHORDL(maxpr),SMPSTA(maxpoly),NMPPC(maxpoly),
     +POLYCL(maxcell,maxpoly,3),ROUGHN(maxcell)
C=======================================================================
C   READ INPUT
C   PERFORM CHECKS
C   COMPUTE IPLEFT, IPRGHT
C   FIND "SMOOTH PIERS"
C   COMPUTE NUMBER OF CELLS
C   COMPUTE POINTS FOR EACH CELL
C   COMPUTE DEPTH/HYDRAULIC-RADIUS/AREA/TOP-WIDTH CURVE
C   PRINT CURVE
C=======================================================================
C PERFORM ALL READS FOR THIS BRIDGE
C=======================================================================
C
C READ BC LINE
C
cim      write(*,*) 1
      WIDEMAX = 0.0
      READ(N5,*,ERR=888,END=9000) CC,BRDGNO,NUMHN,NUMST,NMPIER
      IF(CC.NE.'C5') THEN
      WRITE(N6,105) CC
 105  FORMAT(/,' ERROR:  EXPECTED TO READ C5 BUT FOUND ',A)
      STOP 'ERROR:  EXPECTED TO READ C5'
      endif
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C echo input
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      WRITE(N6,106) BRDGNO,NUMHN,NUMST,NMPIER
 106  FORMAT(/,10X,'BRDGNO  NUMHN  NUMST  NMPIER',/,2X,F15.2,1X,
     +I3,4X,I3,3X,I3)
      write(n6,*) IBR,ICOND,ROUGH(ICOND)
cim check that this is the correct one
      if (BRDGNO.NE.STHETA(ICOND)) then
      write(n6,*) 'ERROR - '
      write(N6,*) 'Bridge data may not be in same order as ',
     a'they appear in C1 lines'
      write(N6,*) 'Was looking for bridge data ',STHETA(ICOND),
     a' but found bridge data for ',BRDGNO
      endif
cim check against maximum allowed
      if (numhn.gt.maxhn) then
      write(n6,*)
      write(n6,*) 'ERROR - NUMHN = ',numhn,
     a' which is greater than maximum allows (',maxhn,')'
      stop 'ERROR - NUMHN is too large'
      endif
      if (numst.gt.maxst) then
      write(n6,*)
      write(n6,*) 'ERROR - NUMST = ',numst,
     a' which is greater than maximum allows (',maxst,')'
      stop 'ERROR - NUMST is too large'
      endif
      if (nmpier.gt.maxpr) then
      write(n6,*)
      write(n6,*) 'ERROR - NPPIER = ',NMPIER,
     a' which is greater than maximum allows (',maxpr,')'
      stop 'ERROR - NMPIER is too large'
      endif
      if (IBR.gt.maxbr) then
      write(n6,*)
      write(n6,*) 'ERROR - TOO MANY BRIDGES INPUT'
      write(n6,*) 'IBR = ',IBR,
     a' which is greater than maximum allows (',maxbr,')'
      stop 'ERROR - TOO MANY BRIDGES'
      endif
C
C READ HN LINE
C
      READ(N5,*,ERR=888) CC,(VMAN(J),STMAN(J),J=1,NUMHN)
      IF(CC.NE.'C6') THEN
      WRITE(N6,107) CC
 107  FORMAT(/,'ERROR:  EXPECTED TO READ C6 BUT FOUND ',A)
      stop 'ERROR:  EXPECTED TO READ C6'
      endif
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C echo distance,mannings n data
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      write(N6,*)
      write(N6,*) ' HN DATA '
      DO 109 J=1,NUMHN
      WRITE(N6,108) j,VMAN(j),stman(j)
 108  FORMAT(i5,F6.3,2X,F9.2)
 109  CONTINUE
C
C READ GR LINE
C   NOTE:  INPUT FORMAT DIFFERS SLIGHTLY FROM GETCUR SINCE ALL VALUES ARE
C          EXPECTED TO BE ON THE SAME LINE--CAN TOUCH UP LATER IF NECESSARY
C          They can loop around, just don't include cc on subsquent lines
      READ(N5,*,ERR=888) CC,((ELSTA(I,J),I=1,2),J=1,NUMST)
      IF(CC.NE.'C7') then
      WRITE(N6,120) CC
 120  FORMAT(/,'ERROR:  EXPECTED TO READ C7 BUT FOUND ',A)
      stop 'ERROR:  EXPECTED TO READ C7'
      endif
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C Echo gr data
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      write(n6,*)
      write(n6,*) 'GR DATA INPUT'
      DO 123 J=1,NUMST
      WRITE(N6,121) j,(ELSTA(I,J),I=1,2)
 121  FORMAT(I5,F9.2,2X,F9.2)
 123  CONTINUE
C
C READ PR LINE
C
      NUMPIR=NMPIER
      IF(NMPIER.EQ.0) NUMPIR=1
      READ(N5,*,ERR=888) CC,(pierw(J),pclsta(j),chordl(j),J=1,NUMPIR)
      IF(CC.NE.'C8') THEN
      WRITE(N6,125)
 125  FORMAT(/, 'ERROR:  EXPECTED TO READ C8 BUT FOUND',A)
      STOP 'ERROR:  EXPECTED TO READ C8'
      endif
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C echo data
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
      write(n6,*)
      write(n6,*) ' Pier data input'
      DO 126 J=1,NUMPIR
      WRITE(N6,1266) j,pierw(J),pclsta(j),chordl(j)
 1266 FORMAT(i5,F9.2,2X,F9.2,2X,F9.2)
 126  CONTINUE
      DO 127 j=1,NUMPIR
C   DIVIDE BY 2.0 SINCE ALL CALCULATIONS WILL INVOLVE PIER EDGES
        PIERW(j)=pierw(j)/2.
 127  CONTINUE
      IF(NMPIER.EQ.0) PIERW(1)=0.0
C
C FIND MIN GR ELEVATION POINT
C
      ELMIN =  99999.0
      DO 130 j= 1,NUMST
 130  IF(ELSTA(1,j).LT.ELMIN) ELMIN = ELSTA(1,j)
C
C FIND MAX PR LOW CHORD POINT
C
      ELMAX = -99999.0
      IF(NMPIER.EQ.0) THEN
        ELMAX=CHORDL(1)
       ELSE
      DO 140 j = 1,NMPIER
 140  IF(CHORDL(j).GT.ELMAX) ELMAX = CHORDL(j)
      ENDIF
C
C CHECK IF NH STATIONS DEFINED TO END OF CROSS-SECTION
C
      IF(STMAN(NUMHN).LT.ELSTA(2,NUMST)) then
      WRITE(N6,142)
 142  FORMAT(/, 'ERROR:  ROUGHNESSES ON HN LINE NOT DEFINED TO END OF',
     +' CROSS-SECTION')
      stop 'ROUGHNESSES NOT DEFINED TO END OF CROSS-SECTION'
      end if
C
C CHECK IF GR STATIONS ARE IN THE WRONG ORDER
C
      DO 150 j = 2,NUMST
      IF(ELSTA(2,j)-ELSTA(2,j-1).LT.-0.001)  then
      WRITE(N6,145) elsta(2,j-1),elsta(2,j)
 145  FORMAT(/, 'ERROR:  GR STATIONS OUT OF SEQUENCE',
     1' Station 1 - ',f10.3,' Station 2 - ',f10.3)
      stop 'ERROR:  GR STATIONS OUT OF SEQUENCE'
      endif
 150  CONTINUE
C
C CHECK IF PR STATIONS ARE IN WRONG ORDER
C
      IF(NMPIER.GE.2) THEN
      DO 160 j = 2,NMPIER
      IF(PCLSTA(j)-PIERW(j)-PCLSTA(j-1)-PIERW(j-1).LT.-0.001) then
      WRITE(N6,155) j-1,j
 155  FORMAT(/,'ERROR:  PIER STATIONS OUT OF SEQUENCE OR PIERS OVERLAP',
     1' Pier 1 - ',i10,' Pier 2 - ',i10)
      stop 'ERROR:  PIER STATIONS OUT OF SEQUENCE OR PIERS OVERLAP'
      endif
 160  CONTINUE
      ENDIF
C
C CHECK IF FIRST PIER IS LEFT of first station
C
      IF(NMPIER.GT.0) THEN
      IF(PCLSTA(1)+PIERW(1)-ELSTA(2,1).LT.-0.0001) then
      WRITE(N6,170)
 170  FORMAT(/,'ERROR:  FIRST PIER LEFT OF FIRST STATION')
      stop 'ERROR:  FIRST PIER LEFT OF FIRST STATION'
      endif
      ENDIF
C
C CHECK IF LAST PIER IS RIGHT of last station
C
      IF(NMPIER.GT.0) THEN
      IF(PCLSTA(NMPIER)-PIERW(NMPIER)-ELSTA(2,NUMST).GT.0.0001) THEN
      WRITE(N6,180)
 180  FORMAT(/,'ERROR:  LAST PIER IS RIGHT OF LAST STATION')
      STOP 'ERROR:  LAST PIER IS RIGHT OF LAST STATION'
      ENDIF
      ENDIF
C
C COMPUTE IPLEFT
C  IPLEFT     = 0 IF LEFT OF LEFT-MOST CELL IS DEFINED BY PR POINT
C             = 1 IF LEFT OF LEFT-MOST CELL IS DEFINED BY GR POINT(S)
C  IF X-INTERCEPT OF CHORDL(1) AND GR POINTS IS LEFT OF PCLSTA(1)-
C  PIERW(1), THEN IPLEFT=1.  OTHERWISE, IPLEFT=0
C
C CHECK TO SEE IF FIRST GR POINT IS LEFT AND LOWER THAN OR EQUAL TO THE
C FIRST LOW CHORD ELEVATION
        LOLABV=1
      IF(ELSTA(1,1)-CHORDL(1).LE.0.001.AND.ELSTA(2,1)-PCLSTA(1)+PIERW(1)
     +.LE.-.001) THEN
        IPLEFT=1
        ICASEL=3
       ELSE
C LOLABV = ORDER OF LAST LEFT POINT ABOVE OR EQUAL TO LOW CHORD
        DO 190 I7 = 2,NUMST
          IF(ELSTA(1,I7)-CHORDL(1).GT.-.001) THEN
            LOLABV=I7
           ELSE
            GOTO 200
          ENDIF
 190    CONTINUE
C  FIND POINT OF INTERSECTION WITH LOW CHORD AND DETERMINE WHICH SIDE
C  OF PIER IT IS ON.  DETERMINE ICASEL.  REDEFINE STATION AND ELEVATION
C  OF LOLABV AS APPROPRIATE.
C  ICASEL = 1 IF X-INTERCEPT IS GREATER THAN RIGHT OF FIRST PIER
C  ICASEL = 2 IF X-INTERCEPT IS EQUAL TO LEFT OF FIRST PIER
C  ICASEL = 3 IF X-INTERCEPT IS LESS THAN LEFT OF FIRST PIER
C  XINTL  = X-INTERCEPT OF CROSS-SECTION AND LEFT LOW CHORD
 200    XINTL=ELSTA(2,LOLABV+1)+(ELSTA(2,LOLABV)-ELSTA(2,LOLABV+1))*(CHO
     +RDL(1)-ELSTA(1,LOLABV+1))/(ELSTA(1,LOLABV)-ELSTA(1,LOLABV+1))
C ICASEL = 1
        IF(XINTL-PCLSTA(1)-PIERW(1).GE.-.001) THEN
          IPLEFT=0
          ICASEL=1
          ELSTA(1,LOLABV)=CHORDL(1)
          ELSTA(2,LOLABV)=XINTL
          WRITE(N6,210)
 210      FORMAT(/,'ERROR:  LEFT PIER OUT OF BRIDGE OPENING',/,
     18X,' PROBABLE CAUSE IS THE THE LOW CHORD ELEVATION IS LOWER',
     2' THAN ELEVATION OF CHANNEL INVERT AT STATION CORRESPONDING',/,
     38X,'TO CENTERLINE OF PIER') 
         ELSE
C ICASEL = 2
         IF(XINTL-PCLSTA(1)+PIERW(1).GE.-.001.AND.
     +      XINTL-PCLSTA(1)-PIERW(1).LT.0.001) THEN
C REDEFINE LOLABV, STATION, AND ELEVATION
           DO 220 I8 = LOLABV+1,NUMST
             IF(ELSTA(2,I8).GT.PCLSTA(1)+PIERW(1)) THEN
               LOLABV=I8-1
               ELSTA(1,LOLABV)=ELSTA(1,LOLABV+1)+(ELSTA(1,LOLABV)-ELSTA(
     +1,LOLABV+1))*(PCLSTA(1)+PIERW(1)-ELSTA(2,LOLABV+1))/(ELSTA(2,LOLAB
     +V)-ELSTA(2,LOLABV+1))
               ELSTA(2,LOLABV)=PCLSTA(1)+PIERW(1)
               GOTO 230
             ENDIF
 220       CONTINUE
 230       ICASEL=2
           IPLEFT=0
          ELSE
C ICASEL = 3
           IPLEFT=1
           ICASEL=3
           ELSTA(1,LOLABV)=CHORDL(1)
           ELSTA(2,LOLABV)=XINTL
         ENDIF
        ENDIF
      ENDIF
C
C NOW, GO THROUGH SAME PROCESS FOR RIGHT SIDE
C COMPUTE IPRGHT
C  IF X-INTERCEPT OF CHORDL(NUMPIR) AND GR POINTS IS RIGHT OF PCLSTA(NUM
C  IR)-PIERW(NUMPIR), THEN IPLEFT=1.  OTHERWISE, IPLEFT=0
C
C CHECK TO SEE IF LAST GR POINT IS RIGHT AND LOWER THAN OR EQUAL TO THE
C LAST LOW CHORD ELEVATION
      LORABV=NUMST
      IF(ELSTA(1,NUMST)-CHORDL(NUMPIR).LE.0.001.AND.ELSTA(2,NUMST)-PCLST
     +A(NUMPIR)-PIERW(NUMPIR).GE.-.001) THEN
        IPRGHT=1
        ICASER=3
       ELSE
C LORABV = ORDER OF LAST RIGHT POINT ABOVE OR EQUAL TO LOW CHORD
        DO 240 I9 = NUMST-1,LOLABV+1,-1
          IF(ELSTA(1,I9)-CHORDL(NUMPIR).GT.-.001) THEN
            LORABV=I9
           ELSE
            GOTO 250
          ENDIF
 240    CONTINUE
C  FIND POINT OF INTERSECTION WITH LOW CHORD AND DETERMINE WHICH SIDE
C  OF PIER IT IS ON.  DETERMINE ICASER.  REDEFINE STATION AND ELEVATION
C  OF LORABV AS APPROPRIATE.
C  ICASER = 1 IF X-INTERCEPT IS EQUAL TO OR LESS THAN LEFT OF LAST PIER
C  ICASER = 2 IF X-INTERCEPT IS EQUAL TO RIGHT OF LAST PIER
C  ICASER = 3 IF X-INTERCEPT IS GREATER THAN RIGHT OF LAST PIER
C  XINTR  = X-INTERCEPT OF CROSS-SECTION AND RIGHT LOW CHORD
 250    XINTR=ELSTA(2,LORABV-1)+(ELSTA(2,LORABV)-ELSTA(2,LORABV-1))*(CHO
     +RDL(NUMPIR)-ELSTA(1,LORABV-1))/(ELSTA(1,LORABV)-ELSTA(1,LORABV-1))
C ICASER = 1
        IF(XINTR-PCLSTA(NUMPIR)+PIERW(NUMPIR).LE.-.001) THEN
          IPRGHT=0
          ICASER=1
          ELSTA(1,LORABV)=CHORDL(NUMPIR)
          ELSTA(2,LORABV)=XINTR
          WRITE(N6,260)
 260      FORMAT(/, 'ERROR:  RIGHT PIER OUT OF BRIDGE OPENING',/,
     18X,' PROBABLE CAUSE IS THE THE LOW CHORD ELEVATION IS LOWER',
     2' THAN ELEVATION OF CHANNEL INVERT AT STATION CORRESPONDING',/,
     38X,'TO CENTERLINE OF PIER') 
         ELSE
C ICASER = 2
         IF(XINTR-PCLSTA(NUMPIR)-PIERW(NUMPIR).LE.0.001.AND.XINTR-PCLSTA
     +(NUMPIR)+PIERW(NUMPIR).GT.-.001) THEN
C REDEFINE LORABV, STATION, AND ELEVATION
           DO 270 I10 = LORABV-1,LOLABV,-1
             IF(ELSTA(2,I10).LT.PCLSTA(NUMPIR)-PIERW(NUMPIR)) THEN
               LORABV=I10+1
               ELSTA(1,LORABV)=ELSTA(1,LORABV-1)+(ELSTA(1,LORABV)
     +-ELSTA(1,LORABV-1))*(PCLSTA(NUMPIR)-PIERW(NUMPIR)
     +-ELSTA(2,LORABV-1))/(ELSTA(2,LORABV)-ELSTA(2,LORABV-1))
               ELSTA(2,LORABV)=PCLSTA(NUMPIR)-PIERW(NUMPIR)
               GOTO 280
             ENDIF
 270       CONTINUE
 280       ICASER=2
           IPRGHT=0
          ELSE
C ICASER = 3
           IPRGHT=1
           ICASER=3
           ELSTA(1,LORABV)=CHORDL(NUMPIR)
           ELSTA(2,LORABV)=XINTR
         ENDIF
        ENDIF
      ENDIF
C
C     ESTABLISH "SMOOTH PIER" POINTS
C
C ISMCNT    = NUMBER OF SMOOTH PIERS
C SMPSTA(J) = STATION OF JTH SMOOTH PIER
      ISMCNT=0
      DO 300 I11=1,NUMHN
        IF(STMAN(I11)-ELSTA(2,LOLABV).GT.0.01.AND.
     +     STMAN(I11)-ELSTA(2,LORABV).LT.-0.01) THEN
          IF(NMPIER.GT.0) THEN
          DO 290 I12=1,NMPIER
           IF(ABS(STMAN(I11)-PCLSTA(I12)).LT.PIERW(I12)+.01) GOTO 300
 290      CONTINUE
          ENDIF
         ISMCNT=ISMCNT+1
         SMPSTA(ISMCNT)=STMAN(I11)
         ENDIF
 300  CONTINUE
C
C     ESTABLISH POINTS FORMING POLYGON OF EACH CELL
C
      NUMCEL=NMPIER+IPLEFT+IPRGHT+ISMCNT-1
C ICNTGR            = COUNTER FOR NUMBER GR POINTS
C ICNTPR            = COUNTER FOR PIERS
C ICNTSM            = COUNTER FOR SMOOTH PIERS
C NMPPC(N)          = ORDER NUMBER/TOTAL NUMBER OF POINTS DEFINING THE
C                     CELL
C POLYCL(ICELL,N,1) = Y-VALUE OF Nth POINT IN THE ICELLth CELL
C POLYCL(ICELL,N,2) = X-VALUE OF Nth POINT IN THE ICELLth CELL
C POLYCL(ICELL,N,3) = TYPE OF POINT OF Nth POINT IN THE ICELLth CELL
C     WHERE TYPE 1. = GR POINT OR GR/PR POINT (SEGMENT TO NEXT POINT IS
C                     NOT VERTICAL
C                2. = PR POINT
C                3. = HN POINT
C                4. = GR/HN POINT
C                5. = GR/PR POINT (SEGMENT TO NEXT POINT IS VERTICAL)
C NPTSR             = NUMBER OF POSSIBLE POINTS REMAINING
      ICNTGR=LOLABV+1
      ICNTPR=1
      IF(ICASEL.EQ.2) ICNTPR=2
      ICNTSM=1
      ICELL=1
      NMPPC(ICELL)=1
C  DEFINE STATIONS OF PIERS AND SMOOTH PIERS OUTSIDE OF ARRAY IN ORDER TO
C  AVOID ADDITIONAL CHECKS
      PCLSTA(NUMPIR+1)=9999999.
      PIERW(NUMPIR+1)=0.
      SMPSTA(ISMCNT+1)=9999999.
C DETERMINE ROUGHNESS OF FIRST CELL
      DO 305 I12A=1,NUMHN
       IF(ELSTA(2,LOLABV)-STMAN(I12A).LT.0.01) THEN
         ROUGHN(1)=VMAN(I12A)
         GOTO 307
       ENDIF
 305  CONTINUE
C DEFINE FIRST POINT OF FIRST CELL
 307  POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)
      POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
      POLYCL(ICELL,NMPPC(ICELL),3)=1.
      NPTSR=LORABV-LOLABV-1+NMPIER+ISMCNT
C
C     BEGIN LOOP FOR ESTABLISHING POINTS FORMING POLYGON OF EACH CELL
C
      DO 350 I13=1,NPTSR
        NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
C PERFORM THE FOLLOWING IF NEXT STATION IS A GR POINT
        IF(ELSTA(2,ICNTGR)-PCLSTA(ICNTPR)+PIERW(ICNTPR).LT.-.01.AND.
     +     ELSTA(2,ICNTGR)-SMPSTA(ICNTSM).LT.-.01) THEN
C^^^^^^ NEED TO INSERT A CHECK FOR A SAWTOOTH IN A CELL THAT MAKES TWO
C^^^^^^ CELLS, I.E., GR INTERSECTS PR  ======> ERROR
          IF(ICNTGR.EQ.LORABV) GOTO 360
          POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,ICNTGR)
          POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,ICNTGR)
          POLYCL(ICELL,NMPPC(ICELL),3)=1.
	IF (NMPPC(ICELL).GT.1) THEN
          IF(ABS(POLYCL(ICELL,NMPPC(ICELL),2)-POLYCL(ICELL,NMPPC(ICELL)-
     +1,2)).LT.0.0001) POLYCL(ICELL,NMPPC(ICELL)-1,3)=5.
	ENDIF
          ICNTGR=ICNTGR+1
          ELSE
C  CHECK TO SEE IF GR POINT APPROXIMATELY EQUAL TO PR OR SMOOTH PIER
C  POINT.  IF SO, ADD TO GR COUNTER AND CHECK FOR LORABV
C   ITMPGR = TEMPORARY COUNTER FOR GR POINTS WITHIN PIERS
         ITMPGR=0
         DO 310 I14=ICNTGR,LORABV
         IF(ABS(PCLSTA(ICNTPR)-ELSTA(2,I14)).LE.PIERW(ICNTPR)+0.01.AND.
     +          PCLSTA(ICNTPR)-SMPSTA(ICNTSM).LE.0.01) ITMPGR=ITMPGR+1
         IF(ABS(SMPSTA(ICNTSM)-ELSTA(2,I14)).LE.0.01.AND.
     +          SMPSTA(ICNTSM)-PCLSTA(ICNTPR)+PIERW(ICNTPR).LT.-0.01)
     +       ITMPGR=ITMPGR+1
 310     CONTINUE
C PERFORM THE FOLLOWING IF NEXT STATION IS A PR POINT
         IF(ELSTA(2,ICNTGR)-PCLSTA(ICNTPR)+PIERW(ICNTPR).GE.-.01.AND.
     +SMPSTA(ICNTSM)-PCLSTA(ICNTPR)+PIERW(ICNTPR).GE.-.01) THEN
           IF(ICNTGR.EQ.LORABV.AND.ICNTPR.EQ.NMPIER.AND.ICASER.EQ.2) GOT
     +O 360
C
C INEXT = 1 IF RIGHT EDGE OF CELL IS A PIER
C       = 2 IF RIGHT EDGE OF CELL IS A SMOOTH PIER
C
            INEXT=1
            POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,ICNTGR-1)+(ELSTA(1,ICNT
     +GR)-ELSTA(1,ICNTGR-1))*(PCLSTA(ICNTPR)-PIERW(ICNTPR)-ELSTA(2,ICNTG
     +R-1))/(ELSTA(2,ICNTGR)-ELSTA(2,ICNTGR-1))
            POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(ICNTPR)-PIERW(ICNTPR)
            POLYCL(ICELL,NMPPC(ICELL),3)=5.
C    GO UP TO LOW CHORD FOR NEXT POINT
            NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
            POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR)
            POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(ICNTPR)-PIERW(ICNTPR)
            POLYCL(ICELL,NMPPC(ICELL),3)=2.
            NMPPC(ICELL)=NMPPC(ICELL)+1
C   NEXT POINT CAN GO BACK TO LAST PIER, TO LOLABV IF FIRST CELL
C   AND CASE IS RIGHT, OR TO A SMOOTH PIER POINT.
C    FIRST IF FOR FIRST CELL CASE
C
            IF(ICELL.EQ.1) THEN
              IF(ICASEL.NE.2) THEN
                POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),3)=1.
               ELSE
                POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(1)
                POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),3)=5.
                NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),3)=1.
              ENDIF
              ELSE
C CLOSE UP CELL THAT IS NOT THE FIRST OR LAST CELL
C  EITHER GO BACK TO PREVIOUS PIER OR PREVIOUS SMOOTH PIER
C
C    FOR PREVIOUS PIER CASE
               IF(POLYCL(ICELL,1,3)-1.1.LE.0.0) THEN
                 POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=5.
                 NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                 POLYCL(ICELL,NMPPC(ICELL),1)=POLYCL(ICELL,1,1)
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=1.
C    SECOND FOR PREVIOUS SMOOTH PIER CASE
                ELSE
C     IF STILL NOT TO FIRST PIER, INTERPOLATE BETWEEN PIER AND
C     LOLABV POINT
                 IF(ICNTPR.EQ.1) THEN
                  POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)+(CHORDL(1
     +)-ELSTA(1,LOLABV))*(POLYCL(ICELL,1,2)-ELSTA(2,LOLABV))/(PCLSTA(ICN
     +TPR)-PIERW(ICNTPR)-ELSTA(2,LOLABV))
                  ELSE
                  IF(ICNTPR.GT.NMPIER) THEN
C     IF PAST LAST PIER BUT NOT IN LAST CELL, INTERPOLATE BETWEEN LAST
C     PIER AND LORABV
                   POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NMPIER)+(ELSTA(1,
     +LORABV)-CHORDL(NMPIER))*(SMPSTA(ICNTSM)-PCLSTA(NMPIER)-PIERW(NMPIE
     +R))/(ELSTA(2,LORABV)-PCLSTA(NMPIER)-PIERW(NMPIER))
                  ELSE
C     PAST THE FIRST PIER AND NOT PAST THE LAST PIER, SO INTERPOLATE
C     BETWEEN ADJACENT PIERS
                  POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)+(CHORDL(
     +ICNTPR)-CHORDL(ICNTPR-1))*(POLYCL(ICELL,1,2)-PCLSTA(ICNTPR-1)-PIER
     +W(ICNTPR-1))/(PCLSTA(ICNTPR)-PIERW(ICNTPR)-PCLSTA(ICNTPR-1)-PIERW(
     +ICNTPR-1))
                 ENDIF
                 ENDIF
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=3.
                 NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                 POLYCL(ICELL,NMPPC(ICELL),1)=POLYCL(ICELL,1,1)
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=4.
               ENDIF
            ENDIF
           ICNTPR=ICNTPR+1
            ELSE
C PERFORM THE FOLLOWING IF NEXT STATION IS AN HN POINT
 320       INEXT=2
            POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,ICNTGR-1)+(ELSTA(1,ICNT
     +GR)-ELSTA(1,ICNTGR-1))*(SMPSTA(ICNTSM)-ELSTA(2,ICNTGR-1))/(ELSTA(2
     +,ICNTGR)-ELSTA(2,ICNTGR-1))
            POLYCL(ICELL,NMPPC(ICELL),2)=SMPSTA(ICNTSM)
            POLYCL(ICELL,NMPPC(ICELL),3)=3.
C    GO UP TO LOW CHORD FOR NEXT POINT
C     INTERPOLATE BETWEEN PIER AND LOLABV IF NOT TO FIRST PIER, PIER
C     AND LORABV IF PAST LAST PIER, OR BETWEEN ADJACENT PIERS
            NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
            IF(ICNTPR.EQ.1) THEN
              POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)+(CHORDL(1)-
     +ELSTA(1,LOLABV))*(SMPSTA(ICNTSM)-ELSTA(2,LOLABV))/(PCLSTA(ICNTPR)-
     +PIERW(ICNTPR)-ELSTA(2,LOLABV))
            ELSE
C     INTERPOLATE BETWEEN LAST PIER AND LORABV
              IF(ICNTPR.GT.NMPIER) THEN
                POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NUMPIR)+(ELSTA(1,LOR
     +ABV)-CHORDL(NUMPIR))*(SMPSTA(ICNTSM)-PCLSTA(NUMPIR)-PIERW(NUMPIR))
     +/(ELSTA(2,LORABV)-PCLSTA(NUMPIR)-PIERW(NUMPIR))
               ELSE
C     INTERPOLATE BETWEEN ADJACENT PIERS
                POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)+(CHORDL(IC
     +NTPR)-CHORDL(ICNTPR-1))*(SMPSTA(ICNTSM)-PCLSTA(ICNTPR-1)-PIERW(ICN
     +TPR-1))/(PCLSTA(ICNTPR)-PIERW(ICNTPR)-PCLSTA(ICNTPR-1)-PIERW(ICNTP
     +R-1))
              ENDIF
            ENDIF
            POLYCL(ICELL,NMPPC(ICELL),2)=SMPSTA(ICNTSM)
            POLYCL(ICELL,NMPPC(ICELL),3)=2.
            NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
C   NEXT POINT CAN GO BACK TO PREVIOUS PIER, TO LOLABV IF FIRST CELL
C   AND CASE IS RIGHT, OR TO THE PREVIOUS SMOOTH PIER
C    FIRST IF IS FOR FIRST CELL CASE
C
            IF(ICELL.EQ.1) THEN
              IF(ICASEL.NE.2) THEN
                POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),3)=1.
               ELSE
                POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(1)
                POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),3)=5.
                NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
                POLYCL(ICELL,NMPPC(ICELL),3)=1.
              ENDIF
              ELSE
C    SECOND IF NOT FOR THE FIRST OR LAST CELL
C     EITHER GO BACK TO PREVIOUS PIER OR PREVIOUS SMOOTH PIER
C
C    FOR PREVIOUS PIER CASE
               IF(POLYCL(ICELL,1,3)-1.1.LE.0.0) THEN
                 POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=5.
                 NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                 POLYCL(ICELL,NMPPC(ICELL),1)=POLYCL(ICELL,1,1)
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=1.
C    FOR PREVIOUS SMOOTH PIER CASE
                ELSE
C     IF STILL NOT TO FIRST PIER, INTERPOLATE BETWEEN PIER AND EITHER
C     LOLABV OR LORABV POINT
                 IF(ICNTPR.EQ.1) THEN
                   IF(SMPSTA(ICNTSM)-PCLSTA(ICNTPR).LE.0.001) THEN
C     INTERPOLATE BETWEEN PIER AND LOLABV
                     POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)+(CHORD
     +L(1)-ELSTA(1,LOLABV))*(POLYCL(ICELL,1,2)-ELSTA(2,LOLABV))/(PCLSTA(
     +ICNTPR)-PIERW(ICNTPR)-ELSTA(2,LOLABV))
                     POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                     POLYCL(ICELL,NMPPC(ICELL),3)=3.
                     NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                    ELSE
C     IF LAST SMOOTH PIER IS BEFORE 0-WIDTH PIER, GO BACK TO 0-WIDTH
C     PIER, THEN BACK TO PREVIOUS SMOOTH PIER
                     IF(SMPSTA(ICNTSM-1)-PCLSTA(NUMPIR).LT.-0.001) THEN
                     POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NUMPIR)
                     POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(NUMPIR)
                     POLYCL(ICELL,NMPPC(ICELL),3)=2.
                     NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                     POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)+(CHORD
     +L(1)-ELSTA(1,LOLABV))*(POLYCL(ICELL,1,2)-ELSTA(2,LOLABV))/(PCLSTA(
     +ICNTPR)-PIERW(ICNTPR)-ELSTA(2,LOLABV))
                     POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                     POLYCL(ICELL,NMPPC(ICELL),3)=3.
                     NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                      ELSE
C      INTERPOLATE BETWEEN PIER AND LORABV
                     POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NUMPIR)+(ELSTA(
     +1,LORABV)-CHORDL(NUMPIR))*(SMPSTA(ICNTSM)-PCLSTA(NUMPIR))/(ELSTA(2
     +,LORABV)-PCLSTA(NUMPIR))
                     POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                     POLYCL(ICELL,NMPPC(ICELL),3)=3.
                     NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                      ENDIF
                     ENDIF
                   ELSE
C     PAST THE FIRST PIER, SO INTERPOLATE BETWEEN ADJACENT PIERS OR LAST
C     PIER AND LORABV
C
C       INTERPOLATE BETWEEN LAST PIER AND LORABV
                    IF(ICNTPR.GT.NMPIER) THEN
                     POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NMPIER)+(ELSTA(
     +1,LORABV)-CHORDL(NMPIER))*(SMPSTA(ICNTSM)-PCLSTA(NMPIER)-PIERW(NMP
     +IER))/(ELSTA(2,LORABV)-PCLSTA(NMPIER)-PIERW(NMPIER))
                     POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                     POLYCL(ICELL,NMPPC(ICELL),3)=3.
                     NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                    ELSE
C       INTERPOLATE BETWEEN ADJACENT PIERS
                  POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)+(CHORDL(
     +ICNTPR)-CHORDL(ICNTPR-1))*(POLYCL(ICELL,1,2)-PCLSTA(ICNTPR-1)-PIER
     +W(ICNTPR))/(PCLSTA(ICNTPR)-PIERW(ICNTPR)-PCLSTA(ICNTPR-1)-PIERW(IC
     +NTPR))
                     POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                     POLYCL(ICELL,NMPPC(ICELL),3)=3.
                     NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
                    ENDIF
                 ENDIF
                 POLYCL(ICELL,NMPPC(ICELL),1)=POLYCL(ICELL,1,1)
                 POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
                 POLYCL(ICELL,NMPPC(ICELL),3)=4.
               ENDIF
            ENDIF
           ICNTSM=ICNTSM+1
          ENDIF
C  SEED FIRST POINT FOR NEXT CELL AND RESET COUNTERS
         ICELL=ICELL+1
         if (icell.gt.maxcell) go to 9991
         NMPPC(ICELL)=1
         ICNTGR=ICNTGR+ITMPGR
C   DO THE FOLLOWING IF NEXT CELL BEGINS WITH A PIER
         IF(INEXT.NE.2) THEN
            POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,ICNTGR-1)+(ELSTA(1,ICNT
     +GR)-ELSTA(1,ICNTGR-1))*(PCLSTA(ICNTPR-1)+PIERW(ICNTPR-1)-ELSTA(2,I
     +CNTGR-1))/(ELSTA(2,ICNTGR)-ELSTA(2,ICNTGR-1))
           POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(ICNTPR-1)+PIERW(ICNTPR-1)
            POLYCL(ICELL,NMPPC(ICELL),3)=1.
C       DEFINE ROUGHNESS FOR NEW CELL
      DO 330 I14A=1,NUMHN
       IF(POLYCL(ICELL,NMPPC(ICELL),2)-STMAN(I14A).LT.0.01) THEN
         ROUGHN(ICELL)=VMAN(I14A)
         GOTO 350
       ENDIF
 330  CONTINUE
C    OR DO THE FOLLOWING IF NEXT CELL BEGINS WITH A SMOOTH PIER
         ELSE
            POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,ICNTGR-1)+(ELSTA(1,ICNT
     +GR)-ELSTA(1,ICNTGR-1))*(SMPSTA(ICNTSM-1)-ELSTA(2,ICNTGR-1))/(ELSTA
     +(2,ICNTGR)-ELSTA(2,ICNTGR-1))
            POLYCL(ICELL,NMPPC(ICELL),2)=SMPSTA(ICNTSM-1)
            POLYCL(ICELL,NMPPC(ICELL),3)=4.
C       DEFINE ROUGHNESS FOR NEW CELL
      DO 340 I14B=1,NUMHN
       IF(POLYCL(ICELL,NMPPC(ICELL),2)-STMAN(I14B).LT.0.01) THEN
         ROUGHN(ICELL)=VMAN(I14B)
         GOTO 350
       ENDIF
 340  CONTINUE
         ENDIF
        ENDIF
 350  CONTINUE
C  FINISH LAST CELL
 360  POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LORABV)
      POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LORABV)
      POLYCL(ICELL,NMPPC(ICELL),3)=5.
      IF(ICASER.EQ.3) THEN
      POLYCL(ICELL,NMPPC(ICELL),3)=2.
CWCH, 7/16/99 SOMEHOW POSSIBLE TO GET HERE WITH NMPPC(ICELL)=1.  CAUSES
C	ZERO SUBSCRIPT IN IF-STATEMENT.  CHECK FOR THIS AND USE 
C     DEFAULT POLYCL(ICELL,NMPCC(ICELL),3) = TYPE = 2.
	     IF (NMPPC(ICELL).GT.1) THEN
        IF(ABS(POLYCL(ICELL,NMPPC(ICELL),2)-POLYCL(ICELL,NMPPC(ICELL)-1,
     +2)).LT.0.0001) POLYCL(ICELL,NMPPC(ICELL)-1,3)=5.0
	  ENDIF
           ENDIF
      NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
C    GO UP TO LOW CHORD FOR NEXT POINT IF ICASER=2
      IF(ICASER.EQ.2) THEN
        POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NMPIER)
        POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LORABV)
        POLYCL(ICELL,NMPPC(ICELL),3)=2.
        NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
      ENDIF
      IF(ICELL.EQ.1) THEN
C   FOR CASE WITH ONLY ONE CELL, GO BACK TO 0-WIDTH PIER, THEN GO BACK
C   TO LOLABV
C    GO TO 0-WIDTH PIER FOR NEXT POINT
        IF(NMPIER.EQ.0) THEN
          POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(NUMPIR)
          POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(NUMPIR)
          POLYCL(ICELL,NMPPC(ICELL),3)=2.
          NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
        ENDIF
        IF(ICASEL.EQ.2) THEN
          POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(1)
          POLYCL(ICELL,NMPPC(ICELL),2)=ELSTA(2,LOLABV)
          POLYCL(ICELL,NMPPC(ICELL),3)=1.
          NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
        ENDIF
C  FOR CASES WITH MORE THAN ONE CELL
      ELSE
C   FOR LEFT OF CELL BEGINNING WITH A PIER
        IF(INEXT.NE.2) THEN
C    GO TO PIER
          POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)
          POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(ICNTPR-1)+PIERW(ICNTPR-1)
          POLYCL(ICELL,NMPPC(ICELL),3)=5.
          NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
C   FOR LEFT OF CELL BEGINNING WITH A SMOOTH PIER
        ELSE
C     FOR BRIDGES WITH AT LEAST ONE PIER
          IF(NMPIER.NE.0) THEN
            POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(ICNTPR-1)+
     +(ELSTA(1,LORABV)-CHORDL(ICNTPR-1))*(SMPSTA(ICNTSM-1)-
     +PCLSTA(ICNTPR-1)-PIERW(ICNTPR-1))/(ELSTA(2,LORABV)-
     +PCLSTA(ICNTPR-1)-PIERW(ICNTPR-1))
            POLYCL(ICELL,NMPPC(ICELL),2)=SMPSTA(ICNTSM-1)
            POLYCL(ICELL,NMPPC(ICELL),3)=3.
            NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
C     FOR BRIDGES WITH NO PIERS
          ELSE
C       FOR LAST SMOOTH PIER BEFORE 0-WIDTH PIER
            IF(SMPSTA(ICNTSM-1)-PCLSTA(NUMPIR).LT.-0.001) THEN
              POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(1)
              POLYCL(ICELL,NMPPC(ICELL),2)=PCLSTA(1)
              POLYCL(ICELL,NMPPC(ICELL),3)=2.
              NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
              POLYCL(ICELL,NMPPC(ICELL),1)=ELSTA(1,LOLABV)+(CHORDL(1)-
     +ELSTA(1,LOLABV))*(POLYCL(ICELL,1,2)-ELSTA(2,LOLABV))/(PCLSTA(1)-
     +ELSTA(2,LOLABV))
              POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
              POLYCL(ICELL,NMPPC(ICELL),3)=3.
              NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
C       FOR LAST SMOOTH PIER AFTER 0-WIDTH PIER
            ELSE
              POLYCL(ICELL,NMPPC(ICELL),1)=CHORDL(1)+(ELSTA(1,LORABV)-
     +CHORDL(1))*(SMPSTA(ICNTSM-1)-PCLSTA(1))/
     +(ELSTA(2,LORABV)-PCLSTA(1))
              POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
              POLYCL(ICELL,NMPPC(ICELL),3)=3.
              NMPPC(ICELL)=NMPPC(ICELL)+1
        if (nmppc(icell).gt.maxpoly) go to 9990
            ENDIF
          ENDIF
        ENDIF
      ENDIF
C    GO BACK TO FIRST POINT TO CLOSE OUT CELL
        POLYCL(ICELL,NMPPC(ICELL),1)=POLYCL(ICELL,1,1)
        POLYCL(ICELL,NMPPC(ICELL),2)=POLYCL(ICELL,1,2)
        POLYCL(ICELL,NMPPC(ICELL),3)=1.
C^^^ TEMPORARY WRITE STATEMENT TO SEE IF POLYGONS ARE BEING CALCULATED
C^^^ CORRECTLY
CIM      DO 2200 I15=1,NUMCEL
CIM        WRITE(N6,2010) I15,brdgno
CIM 2010   FORMAT(/,' CELL NUMBER ',I2,' FOR BRIDGE NUMBER ',F10.0)
CIM        DO 2190 I16=1,NMPPC(I15)
CIM          WRITE(N6,2020) I16,(POLYCL(I15,I16,I17),I17=1,3)
CIM 2020   FORMAT(/, 'POINT ',I3,' , Y= ',F9.2,' X= ',F9.2,' TYPE= ',F2.0)
CIM 2190 CONTINUE
CIM 2200 CONTINUE
C^^^^^
C^^^^^^^^^
      DEEP(ICOND) = ELMAX - ELMIN
      ELDEL = DEEP(ICOND)/(maxbpnt-1.0)
      DEPTH = ELMIN-ELDEL
C=======================================================================
C
C   COMPUTE DEPTH/HYDRAULIC-RADIUS/AREA/TOP-WIDTH CURVE
C     ALL HYDRAULIC RADIUS CALCULATIONS WILL BE NORMALIZED TO VMAN(1)
C
C^^^^ TEMPORARY WRITE TO CHECK BRIDGE CURVE
      WRITE(N6,2300) BRDGNO,VMAN(1)
 2300 FORMAT(/,'       DATA FOR BRIDGE ',F15.2,/,
     A'       NOTE HYD.RAD. NORMALIZED TO MANNINGS N = ',F10.4,/,
     A'            DEPTH   HYD. RAD.   AREA    TOP WIDTH    FLOW',/,
     A'             FT       FT        FT^2       FT         CFS')
C^^^^
      DO 410 I17=1,maxbpnt
      AREA=0.0
      TOPWID=0.0
      CONVEY=0.0
      DEPTH=DEPTH+ELDEL
       DO 400 I18=1,NUMCEL
        TMAREA=0.0
        TMWP=0.0
        DO 390 I19=1,NMPPC(I18)-1
C  IF SEGMENT IS SMOOTH PIER, SKIP TO NEXT SINCE AREA AND WP = 0
         IF(ABS(POLYCL(I18,I19,3)-3.).GT.0.01) THEN
C  DO THE FOLLOWING IF THE SEGMENT IS A LOW CHORD
          IF(ABS(POLYCL(I18,I19,3)-2.).LT.0.01) THEN
C   CASE 2:  DEPTH > LOW CHORD
            IF(DEPTH-POLYCL(I18,I19,1).GE.-.00001.AND.DEPTH-POLYCL(I18,I
     +19+1,1).GE.-.00001) THEN
              TMAREA=TMAREA-((DEPTH-(POLYCL(I18,I19,1)+POLYCL(I18,I19+1,
     +1))/2.)*(POLYCL(I18,I19,2)-POLYCL(I18,I19+1,2)))
              TMWP=TMWP+((POLYCL(I18,I19,1)-POLYCL(I18,I19+1,1))**2+(POL
     +YCL(I18,I19+1,2)-POLYCL(I18,I19,2))**2)**0.5
                TOPWID=TOPWID+POLYCL(I18,I19+1,2)-POLYCL(I18,I19,2)
            ELSE
C   CASE 3:  DEPTH > RIGHT SIDE AND DEPTH < LEFT SIDE
               IF(DEPTH-POLYCL(I18,I19,1).GE.-.00001.AND.DEPTH-POLYCL(I1
     +8,I19+1,1).LT.-.00001) THEN
                 XINT=POLYCL(I18,I19+1,2)+(POLYCL(I18,I19,2)-POLYCL(I18,
     +I19+1,2))*(DEPTH-POLYCL(I18,I19+1,1))/(POLYCL(I18,I19,1)-POLYCL(I1
     +8,I19+1,1))
                  TMAREA=TMAREA-((DEPTH-POLYCL(I18,I19,1))*(POLYCL(I18,I
     +19,2)-XINT)*0.5)
              TMWP=TMWP+((POLYCL(I18,I19,1)-DEPTH)**2+(POLYCL(I18,I19,2)
     +-XINT)**2)**0.5
                 TOPWID=TOPWID-POLYCL(I18,I19,2)+XINT
               ELSE
C   CASE 4:  DEPTH < RIGHT SIDE AND DEPTH > LEFT SIDE
                 IF(DEPTH-POLYCL(I18,I19,1).LT.-.00001.AND.DEPTH-POLYCL(
     +I18,I19+1,1).GE.-.00001) THEN
                 XINT=POLYCL(I18,I19+1,2)+(POLYCL(I18,I19,2)-POLYCL(I18,
     +I19+1,2))*(DEPTH-POLYCL(I18,I19+1,1))/(POLYCL(I18,I19,1)-POLYCL(I1
     +8,I19+1,1))
                  TMAREA=TMAREA-((DEPTH-POLYCL(I18,I19+1,1))*(XINT-POLYC
     +L(I18,I19+1,2))*0.5)
              TMWP=TMWP+((POLYCL(I18,I19+1,1)-DEPTH)**2+(POLYCL(I18,I19+
     +1,2)-XINT)**2)**0.5
                 TOPWID=TOPWID+POLYCL(I18,I19+1,2)-XINT
C   CASE 1:  DEPTH < LOW CHORD, SO DO NOTHING
                 ENDIF
               ENDIF
            ENDIF
          ELSE
C  DO THE FOLLOWING IF THE SEGMENT IS ALONG A PIER (I.E., VERTICAL)
            IF(ABS(POLYCL(I18,I19,3)-5.).LT.0.01) THEN
              TMWP=TMWP+AMAX1(DEPTH-AMIN1(POLYCL(I18,I19,1),POLYCL(I18,I
     +19+1,1)),0.0)
            ELSE
C  DO THE FOLLOWING IF THE SEGMENT IS ALONG THE BOTTOM OF THE CELL
C
C   CASE 2:  DEPTH > BOTTOM
              IF(DEPTH-POLYCL(I18,I19,1).GE.-.00001.AND.DEPTH-POLYCL(I18
     +,I19+1,1).GE.-.00001) THEN
                TMAREA=TMAREA+((DEPTH-(POLYCL(I18,I19,1)+POLYCL(I18,I19+
     +1,1))/2.)*(POLYCL(I18,I19+1,2)-POLYCL(I18,I19,2)))
                TMWP=TMWP+((POLYCL(I18,I19,1)-POLYCL(I18,I19+1,1))**2+(P
     +OLYCL(I18,I19+1,2)-POLYCL(I18,I19,2))**2)**0.5
                TOPWID=TOPWID+POLYCL(I18,I19+1,2)-POLYCL(I18,I19,2)
              ELSE
C   CASE 3:  DEPTH > RIGHT SIDE AND DEPTH < LEFT SIDE
               IF(DEPTH-POLYCL(I18,I19+1,1).GE.-.00001.AND.DEPTH-POLYCL(
     +I18,I19,1).LT.-.00001) THEN
                 XINT=POLYCL(I18,I19,2)+(POLYCL(I18,I19+1,2)-POLYCL(I18,
     +I19,2))*(POLYCL(I18,I19,1)-DEPTH)/(POLYCL(I18,I19,1)-POLYCL(I18,
     +I19+1,1))
                  TMAREA=TMAREA+((DEPTH-POLYCL(I18,I19+1,1))*(POLYCL(I18
     +,I19+1,2)-XINT)*0.5)
                  TMWP=TMWP+((POLYCL(I18,I19+1,1)-DEPTH)**2+(POLYCL(I18,
     +I19+1,2)-XINT)**2)**0.5
                 TOPWID=TOPWID+POLYCL(I18,I19+1,2)-XINT
               ELSE
C   CASE 4:  DEPTH < RIGHT SIDE AND DEPTH > LEFT SIDE
                 IF(DEPTH-POLYCL(I18,I19+1,1).LT.-.00001.AND.DEPTH-POLYC
     +L(I18,I19,1).GE.-.00001) THEN
                   XINT=POLYCL(I18,I19,2)+(POLYCL(I18,I19+1,2)-POLYCL(I1
     +8,I19,2))*(DEPTH-POLYCL(I18,I19,1))/(POLYCL(I18,I19+1,1)-POLYCL(I1
     +8,I19,1))
                   TMAREA=TMAREA+((DEPTH-POLYCL(I18,I19,1))*(XINT-POLYCL
     +(I18,I19,2))*0.5)
                   TMWP=TMWP+((POLYCL(I18,I19,1)-DEPTH)**2+(POLYCL(I18,I
     +19,2)-XINT)**2)**0.5
                   TOPWID=TOPWID+XINT-POLYCL(I18,I19,2)
C   CASE 1:  DEPTH < BOTTOM, SO DO NOTHING
                 ENDIF
               ENDIF
              ENDIF
            ENDIF
          ENDIF
         ENDIF
C^^^^ TEMPORARY WRITE TO CHECK POINT COMPUTATIONS
C      WRITE(N6,2346) I18,I19,TMAREA,TMWP,TOPWID
C2346 FORMAT(' CELL #',I3,' POINT #',I3,' TMAREA= ',F8.1,' TMWP= ',F7.2,
C     +' TOPWID = ',F8.1)
C^^^^

  390   CONTINUE
C^^^^ TEMPORARY WRITE TO CHECK CELL COMPUTATIONS
C      WRITE(N6,2348) I18,TMAREA,TMWP,TOPWID
C2348 FORMAT(' CELL #',I3,' TMAREA= ',F8.1,' TMWP= ',F7.2,' TOPWID = ',F
C     +8.1)
C^^^^
        AREA=AREA+TMAREA
        IF(TMAREA.GT.0.0.AND.TMWP.GT.0.0) CONVEY=CONVEY+
     +TMAREA**(5.0/3.0)/TMWP**(2.0/3.0)/ROUGHN(I18)
  400  CONTINUE
      BRDEP=DEPTH-ELMIN
      BRHYD(IBR,I17)=0.0
C     ALL HYDRAULIC RADIUS CALCULATIONS WILL BE NORMALIZED TO VMAN(1)
      IF(AREA.GT.0.0) BRHYD(IBR,I17)=(CONVEY/AREA*VMAN(1))**1.5
      ROUGH(ICOND)=VMAN(1)
      BRAREA(IBR,I17)=AREA
      BRTW(IBR,I17)=TOPWID
      WIDEMAX = AMAX1(WIDEMAX,TOPWID)
C^^^^ TEMPORARY WRITE TO CHECK BRIDGE CURVE
      FLOW = 1.49/ROUGH(ICOND)*BRAREA(IBR,I17)*
     A       BRHYD(IBR,I17)**(2.0/3.0)*SQRT(SPHI(ICOND))
      WRITE(N6,2350) brdep,brhyd(ibr,i17),
     abrarea(ibr,i17),brtw(ibr,i17),FLOW
 2350 FORMAT(10X,F7.2,1X,F11.4,1X,F6.1,1X,F11.1,F12.0)
C^^^^
  410 CONTINUE
 888  CONTINUE
 9000 CONTINUE
CIM  INITIAL ADDITIONAL ARRAYS AND SET LIMITS ON WIDTH AND RADIUS
CIM  Following example of HRNORM, Don't allow a zero radius at zero depth
      RFULL(ICOND) = BRHYD(IBR,MAXBPNT)
      BRHYD(IBR,1) = BRHYD(IBR,MAXBPNT) * 0.01
      AFULL(ICOND) = BRAREA(IBR,MAXBPNT)
      WIDE(ICOND) = WIDEMAX
CIM Following example of TWNORM, Set don't use zero top width at zero
cim depth and full depth
      BRTW(IBR,1) = BRTW(IBR,2)
      BRTW(IBR,MAXBPNT) = BRTW(IBR,MAXBPNT-1)
CIM
      RETURN
 9990 write(n6,*) 'ERROR - TOO MANY POINT IN BRIDGE CELL POLYGON'
      write(n6,*) '        Maximum allowed = ',maxpoly
      if (jce.eq.0) then
      write(n6,*) '        Error occurred for bridge conduit ',
     ancond(icond),' bridge ',brdgno
      else
      write(n6,*) '        Error occurred for bridge conduit ',
     aacond(icond),' bridge ',brdgno
      endif
      write(n6,*) '        Cell number ',icell
      stop 'ERROR - TOO MANY POINT IN BRIDGE CELL POLYGON'
 9991 write(n6,*) 'ERROR - TOO MANY CELLS IN BRIDGE'
      write(n6,*) '        Maximum allowed = ',maxcell
      if (jce.eq.0) then
      write(n6,*) '        Error occurred for bridge conduit ',
     ancond(icond),' bridge ',brdgno
      else
      write(n6,*) '        Error occurred for bridge conduit ',
     aacond(icond),' bridge ',brdgno
      endif
      stop 'ERROR - TOO MANY CELLS IN BRIDGE'
      END

